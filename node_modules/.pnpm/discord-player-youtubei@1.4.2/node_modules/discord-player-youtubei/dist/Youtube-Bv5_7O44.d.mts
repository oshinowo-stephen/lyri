import { SearchQueryType, Track, BaseExtractor, ExtractorStreamable, ExtractorSearchContext, ExtractorInfo, Playlist, GuildQueueHistory } from 'discord-player';
import Innertube from 'youtubei.js';
import { ProxyAgent } from 'undici';
import { InnerTubeClient, DownloadOptions, InnerTubeConfig } from 'youtubei.js/dist/src/types';
import { Readable } from 'node:stream';
import { Video } from 'youtubei.js/dist/src/parser/nodes';
import { AsyncLocalStorage } from 'node:async_hooks';
import { PoTokenResult } from 'bgutils-js';

interface StreamOptions {
    useClient?: InnerTubeClient;
    highWaterMark?: number;
}
interface RefreshInnertubeOptions {
    filePath: string;
    interval?: number;
}
interface PeerInfo {
    url: string;
    parse?: (url: string, id: string) => string;
}
type TrustedTokenConfig = {
    poToken: string;
    visitorData: string;
};
type QueryBridgeModes = Partial<Record<SearchQueryType, "yt" | "ytmusic">> & {
    default?: "yt" | "ytmusic";
};
interface YoutubeiOptions {
    authentication?: string;
    overrideDownloadOptions?: DownloadOptions;
    createStream?: (q: Track, extractor: YoutubeiExtractor) => Promise<string | Readable>;
    signOutOnDeactive?: boolean;
    streamOptions?: StreamOptions;
    overrideBridgeMode?: "ytmusic" | "yt" | QueryBridgeModes;
    disablePlayer?: boolean;
    ignoreSignInErrors?: boolean;
    innertubeConfigRaw?: InnerTubeConfig;
    trustedTokens?: TrustedTokenConfig;
    cookie?: string;
    proxy?: ProxyAgent;
    peers?: PeerInfo[];
}
interface AsyncTrackingContext {
    useClient: InnerTubeClient;
    highWaterMark?: number;
}
declare class YoutubeiExtractor extends BaseExtractor<YoutubeiOptions> {
    #private;
    static identifier: string;
    innerTube: Innertube;
    _stream: (q: Track, extractor: YoutubeiExtractor) => Promise<ExtractorStreamable>;
    static instance?: YoutubeiExtractor;
    priority: number;
    static ytContext: AsyncLocalStorage<AsyncTrackingContext>;
    setInnertube(tube: Innertube): void;
    setPoToken(token: PoTokenResult, visitorData: string): Promise<void>;
    static getInstance(): YoutubeiExtractor | undefined;
    setClientMode(client: InnerTubeClient): void;
    static getStreamingContext(): AsyncTrackingContext;
    activate(): Promise<void>;
    signIn(tokens: string): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    bridge(track: Track, ext: BaseExtractor | null): Promise<ExtractorStreamable | null>;
    bridgeFromYTMusic(query: string, track: Track): Promise<ExtractorStreamable | null>;
    bridgeFromYT(query: string, track: Track): Promise<ExtractorStreamable | null>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    buildTrack(vid: Video, context: ExtractorSearchContext, pl?: Playlist): Track<any>;
    stream(info: Track<unknown>): Promise<ExtractorStreamable>;
    getRelatedTracks(track: Track<{
        duration_ms: number;
        live: boolean;
    }>, history: GuildQueueHistory<unknown>): Promise<ExtractorInfo>;
    static validateURL(link: string): boolean;
    static parseURL(link: string): string;
    static validateId(id: string): boolean;
}

export { type AsyncTrackingContext as A, type PeerInfo as P, type QueryBridgeModes as Q, type RefreshInnertubeOptions as R, type StreamOptions as S, type TrustedTokenConfig as T, YoutubeiExtractor as Y, type YoutubeiOptions as a };
