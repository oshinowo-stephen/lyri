"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  ChatMessageType: () => ChatMessageType,
  Errors: () => Errors,
  LiveChatEvents: () => LiveChatEvents,
  YoutubeiExtractor: () => YoutubeiExtractor,
  defaultFetch: () => defaultFetch,
  defaultPeerUrlBuilder: () => defaultPeerUrlBuilder,
  generateOauthTokens: () => generateOauthTokens,
  getLiveChat: () => getLiveChat,
  getYoutubeiInstance: () => getYoutubeiInstance,
  objectToToken: () => objectToToken,
  stream: () => stream,
  tokenToObject: () => tokenToObject,
  validateURL: () => validateURL
});
module.exports = __toCommonJS(lib_exports);
var import_youtubei7 = __toESM(require("youtubei.js"));

// lib/common/tokenUtils.ts
function objectToToken(tokens) {
  return Object.entries(tokens).map(([k, v]) => `${k}=${v instanceof Date ? v.toISOString() : v}`).join("; ");
}
function tokenToObject(token) {
  if (!token.includes("; ") || !token.includes("="))
    throw new Error(
      "Error: this is not a valid authentication token. Make sure you are putting the entire string instead of just what's behind access_token="
    );
  const kvPair = token.split("; ");
  const validKeys = [
    "access_token",
    "expiry_date",
    "expires_in",
    "refresh_token",
    "scope",
    "token_type",
    "client"
  ];
  let finalObject = {};
  for (let kv of kvPair) {
    const [key, value] = kv.split("=");
    if (!validKeys.includes(key)) continue;
    finalObject[key] = Number.isNaN(Number(value)) ? value : Number(value);
  }
  const requiredKeys = ["access_token", "expiry_date", "refresh_token"];
  for (const key of requiredKeys) {
    if (!(key in finalObject))
      throw new Error(
        `Error: Invalid authentication keys. Missing the required key ${key}. Make sure you are putting the entire string instead of just what's behind access_token=`
      );
  }
  return finalObject;
}

// lib/Extractor/Youtube.ts
var import_discord_player = require("discord-player");
var import_youtubei6 = __toESM(require("youtubei.js"));

// lib/common/generateYTStream.ts
var import_youtubei2 = require("youtubei.js");

// lib/common/webToReadable.ts
var import_stream = require("stream");
var import_youtubei = require("youtubei.js");
function createReadableFromWeb(readStream, highWaterMark = 1024 * 512) {
  const readable = new import_stream.PassThrough({
    highWaterMark
  });
  (async () => {
    let shouldListen = true;
    for await (const chunk of import_youtubei.Utils.streamToIterable(readStream)) {
      if (readable.destroyed) continue;
      const shouldWrite = readable.write(chunk);
      if (!shouldWrite && shouldListen) {
        shouldListen = false;
        await new Promise((res) => {
          readable.once("drain", () => {
            shouldListen = true;
            res();
          });
        });
      }
    }
  })();
  readable._destroy = () => {
    readStream.cancel();
    readable.destroyed = true;
    readable.destroy();
  };
  return readable;
}

// lib/common/generateYTStream.ts
var DEFAULT_DOWNLOAD_OPTIONS = {
  quality: "best",
  format: "mp4",
  type: "audio"
};
function createWebReadableStream(url, size, innertube) {
  let [start, end] = [0, 1048576 * 10];
  let isEnded = false;
  let abort;
  return new import_youtubei2.Platform.shim.ReadableStream(
    {
      start() {
      },
      pull(controller) {
        if (isEnded) {
          controller.close();
          return;
        }
        if (end >= size) {
          isEnded = true;
        }
        return new Promise(async (resolve, reject) => {
          abort = new AbortController();
          try {
            const chunks = await innertube.actions.session.http.fetch_function(
              `${url}&range=${start}-${end || ""}`,
              {
                headers: {
                  ...import_youtubei2.Constants.STREAM_HEADERS
                },
                signal: abort.signal
              }
            );
            const readable = chunks.body;
            if (!readable || !chunks.ok)
              throw new Error(`Downloading of ${url} failed.`);
            for await (const chunk of import_youtubei2.Utils.streamToIterable(readable)) {
              controller.enqueue(chunk);
            }
            start = end + 1;
            end += size;
            resolve();
          } catch (error) {
            reject(error);
          }
        });
      },
      async cancel() {
        abort.abort();
      }
    },
    {
      highWaterMark: 1,
      size(ch) {
        return ch.byteLength;
      }
    }
  );
}
async function streamFromYT(query, innerTube, options = {
  overrideDownloadOptions: DEFAULT_DOWNLOAD_OPTIONS
}) {
  const context = YoutubeiExtractor.getStreamingContext();
  let id = new URL(query.url).searchParams.get("v");
  if (!id) id = query.url.split("/").at(-1)?.split("?").at(0);
  const videoInfo = await innerTube.getBasicInfo(id, context.useClient);
  if (videoInfo.basic_info.is_live)
    return videoInfo.streaming_data?.hls_manifest_url;
  if (["IOS", "ANDROID", "TV_EMBEDDED"].includes(
    context.useClient
  )) {
    const downloadURL = videoInfo.chooseFormat(
      options.overrideDownloadOptions ?? DEFAULT_DOWNLOAD_OPTIONS
    );
    const download2 = createWebReadableStream(
      `${downloadURL.url}&cpn=${videoInfo.cpn}`,
      downloadURL.content_length,
      innerTube
    );
    return createReadableFromWeb(download2, context.highWaterMark);
  }
  const download = await videoInfo.download(
    options.overrideDownloadOptions ?? DEFAULT_DOWNLOAD_OPTIONS
  );
  const stream2 = createReadableFromWeb(download, context.highWaterMark);
  return stream2;
}

// lib/Extractor/Youtube.ts
var import_node_async_hooks = require("async_hooks");

// lib/utils/index.ts
var import_youtubei5 = require("youtubei.js");

// lib/utils/live/LiveChat.ts
var import_tiny_typed_emitter = require("tiny-typed-emitter");

// lib/utils/live/LiveChatAuthor.ts
var LiveChatAuthor = class {
  username;
  url;
  thumbnail;
  verifiedChannel;
  verifiedArtist;
  isMod;
  id;
  raw;
  constructor(author) {
    this.username = author.name;
    this.url = author.url;
    this.thumbnail = author.best_thumbnail?.url ?? author.thumbnails[0].url;
    this.verifiedChannel = author.is_verified || false;
    this.verifiedArtist = author.is_verified_artist || false;
    this.isMod = author.is_moderator || false;
    this.id = author.id;
    this.raw = author;
  }
};

// lib/utils/live/LiveChatMessage.ts
var ChatMessageType = /* @__PURE__ */ ((ChatMessageType2) => {
  ChatMessageType2[ChatMessageType2["Regular"] = 1] = "Regular";
  ChatMessageType2[ChatMessageType2["Premium"] = 2] = "Premium";
  ChatMessageType2[ChatMessageType2["PremiumSticker"] = 3] = "PremiumSticker";
  return ChatMessageType2;
})(ChatMessageType || {});
var LiveChatMessage = class {
  author;
  type;
  content;
  timestamp;
  constructor(chatUpdate, type) {
    this.author = new LiveChatAuthor(
      chatUpdate.author
    );
    this.type = type;
    this.timestamp = chatUpdate.timestamp || Date.now();
    if (chatUpdate.type === "LiveChatTextMessage" || chatUpdate.type === "LiveChatPaidMessage") {
      this.content = chatUpdate.message.toString();
    }
  }
};

// lib/utils/live/LiveChat.ts
var import_youtubei3 = require("youtubei.js");
var LiveChatEvents = {
  MessageCreate: "messageCreate",
  StreamEnd: "streamEnd"
};
var LiveChat = class {
  chat;
  #eventEmitter = new import_tiny_typed_emitter.TypedEmitter();
  #hasListener = {
    [LiveChatEvents.MessageCreate]: false,
    [LiveChatEvents.StreamEnd]: false
  };
  // this is scuffed but i cant access 'this' inside other non-arrow functions
  chatUpdateHandler = (action) => {
    if (action.is(import_youtubei3.YTNodes.AddChatItemAction)) {
      const { item } = action.as(import_youtubei3.YTNodes.AddChatItemAction);
      switch (item.type) {
        case "LiveChatTextMessage": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 1 /* Regular */)
          );
          break;
        }
        case "LiveChatPaidMessage": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 2 /* Premium */)
          );
          break;
        }
        case "LiveChatPaidSticker": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 3 /* PremiumSticker */)
          );
          break;
        }
        default: {
          break;
        }
      }
    }
  };
  #chatEndHandler = () => {
    this.#eventEmitter.emit(LiveChatEvents.StreamEnd);
  };
  constructor(chat) {
    this.chat = chat;
  }
  on(event, handler) {
    switch (event) {
      case LiveChatEvents.MessageCreate: {
        if (!this.#hasListener[LiveChatEvents.MessageCreate]) {
          this.chat.on("chat-update", this.chatUpdateHandler);
          this.#hasListener[LiveChatEvents.MessageCreate] = true;
        }
        this.#eventEmitter.on(event, handler);
      }
      case LiveChatEvents.StreamEnd: {
        if (!this.#hasListener[LiveChatEvents.StreamEnd]) {
          this.chat.on("end", this.#chatEndHandler);
        }
      }
    }
  }
  destroy() {
    if (this.#hasListener[LiveChatEvents.MessageCreate])
      this.chat.off("chat-update", this.chatUpdateHandler);
    if (this.#hasListener[LiveChatEvents.StreamEnd])
      this.chat.off("end", this.#chatEndHandler);
    this.chat.stop();
  }
};

// lib/utils/live/getLiveChat.ts
var YOUTUBE_URL_REGEX = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(?:-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|live\/|v\/)?)([\w\-]+)(\S+)?$/;
function parseYoutubeVideo(videoUrl) {
  if (!YOUTUBE_URL_REGEX.test(videoUrl))
    throw new Error("This is not a valid video URL");
  const idExtractor = new URL(videoUrl);
  let id = idExtractor.searchParams.get("v");
  if (!id) id = videoUrl.split("/").at(-1)?.split("?").at(0);
  return id;
}
async function getLiveChat(videoUrl, ext) {
  const instance = YoutubeiExtractor.instance ?? ext;
  if (!instance)
    throw new Error("Invoked getLiveChat before player.extractors.register");
  const innertube = instance.innerTube;
  const videoId = parseYoutubeVideo(videoUrl);
  const info = await innertube.getInfo(videoId);
  if (!info.basic_info.is_live) return null;
  const chat = info.getLiveChat();
  chat.start();
  return new LiveChat(chat);
}

// lib/utils/downloader/index.ts
var import_youtubei4 = __toESM(require("youtubei.js"));
var Errors = {
  InvalidURL: new Error("Invalid URL: Expected a URL got a string instead"),
  InvalidYTURL: new Error(
    "Invalid YouTube URL: Expected a YouTube URL but got something else"
  ),
  NoDownload: new Error("Unable to download video")
};
var YOUTUBE_REGEX = /^(https:\/\/(www\.)?youtu(\.be\/[A-Za-z0-9]{11}(.+)?|be\.com\/watch\?v=[A-Za-z0-9]{11}(&.+)?))/gm;
function validateURL(url) {
  try {
    return new URL(url);
  } catch {
    return false;
  }
}
async function stream(url, skipStream, options, tube) {
  const urlObj = validateURL(url);
  if (!urlObj) throw Errors.InvalidURL;
  if (!YOUTUBE_REGEX.test(url)) throw Errors.InvalidYTURL;
  const vidId = urlObj.searchParams.get("v") || url.split("/").at(-1).split("?").at(0);
  const yt = tube || await import_youtubei4.default.create({
    retrieve_player: false
  });
  const info = await yt.getBasicInfo(vidId, "IOS");
  const fmt = info.chooseFormat(
    options || {
      format: "mp4",
      quality: "best",
      type: "audio"
    }
  );
  if (!fmt.url || !fmt.content_length) throw Errors.NoDownload;
  const downloadedUrl = `${fmt.url}&cpn=${info.cpn}`;
  const stream2 = skipStream ? null : createWebReadableStream(downloadedUrl, fmt.content_length, yt);
  const readable = stream2 ? await createReadableFromWeb(stream2) : null;
  return {
    basicInfo: info.basic_info,
    formatInfo: fmt,
    stream: readable,
    downloadedUrl
  };
}

// lib/utils/index.ts
function defaultPeerUrlBuilder(url, id) {
  return `${url}/${id}`;
}
function defaultFetch(player, input, init, proxy) {
  let requestInit = {
    ...init
  };
  if (proxy) {
    requestInit.dispatcher = proxy;
    return import_youtubei5.Platform.shim.fetch(input, requestInit);
  } else {
    return import_youtubei5.Platform.shim.fetch(input, requestInit);
  }
}

// lib/common/peerDownloader.ts
function peerDownloader(id, peer) {
  const peerUrl = typeof peer.parse === "function" ? peer.parse(peer.url, id) : defaultPeerUrlBuilder(peer.url, id);
  return peerUrl;
}

// lib/common/extractVideoID.ts
function extractVideoId(vid) {
  const YOUTUBE_REGEX2 = /^https:\/\/(www\.)?youtu(\.be\/[A-Za-z0-9]{11}(.+)?|be\.com\/watch\?v=[A-Za-z0-9]{11}(&.+)?)/;
  if (!YOUTUBE_REGEX2.test(vid)) throw new Error("Invalid youtube url");
  let id = new URL(vid).searchParams.get("v");
  if (!id) id = vid.split("/").at(-1)?.split("?").at(0);
  return id;
}

// lib/Extractor/Youtube.ts
var validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts)\/)/;
var validQueryDomains = /* @__PURE__ */ new Set([
  "youtube.com",
  "www.youtube.com",
  "m.youtube.com",
  "music.youtube.com",
  "gaming.youtube.com"
]);
var idRegex = /^[a-zA-Z0-9-_]{11}$/;
var YoutubeiExtractor = class _YoutubeiExtractor extends import_discord_player.BaseExtractor {
  static identifier = "com.retrouser955.discord-player.discord-player-youtubei";
  innerTube;
  _stream;
  static instance;
  priority = 2;
  static ytContext = new import_node_async_hooks.AsyncLocalStorage();
  setInnertube(tube) {
    this.innerTube = tube;
  }
  async setPoToken(token, visitorData) {
    const oauthKeys = this.innerTube.session.oauth.oauth2_tokens;
    const newTube = await import_youtubei6.default.create({
      visitor_data: visitorData,
      po_token: token.poToken,
      generate_session_locally: true
    });
    if (oauthKeys) await newTube.session.signIn(oauthKeys);
    this.innerTube = newTube;
    this.debug("YOUTUBEI POTOKEN: SET");
  }
  static getInstance() {
    return this.instance;
  }
  setClientMode(client) {
    if (!this.options.streamOptions) this.options.streamOptions = {};
    this.options.streamOptions.useClient = client;
  }
  static getStreamingContext() {
    const ctx = _YoutubeiExtractor.ytContext.getStore();
    if (!ctx) throw new Error("INVALID INVOKCATION");
    return ctx;
  }
  async activate() {
    this.protocols = ["ytsearch", "youtube"];
    if (this.options.trustedTokens && !this.options.streamOptions?.useClient)
      process.emitWarning(
        'Warning: Using poTokens and default "ANDROID" client which are not compatible'
      );
    const INNERTUBE_OPTIONS = {
      retrieve_player: this.options.disablePlayer === true ? false : true,
      ...this.options.innertubeConfigRaw,
      cookie: this.options.cookie
    };
    if (this.options.trustedTokens) {
      INNERTUBE_OPTIONS.po_token = this.options.trustedTokens.poToken;
      INNERTUBE_OPTIONS.visitor_data = this.options.trustedTokens.visitorData;
    }
    this.innerTube = await import_youtubei6.default.create({
      ...INNERTUBE_OPTIONS,
      fetch: (input, init) => defaultFetch(this.context.player, input, init, this.options.proxy)
    });
    if (typeof this.options.createStream === "function") {
      this._stream = this.options.createStream;
    } else {
      this._stream = (q, _) => {
        return _YoutubeiExtractor.ytContext.run(
          {
            useClient: this.options.streamOptions?.useClient ?? "IOS",
            highWaterMark: this.options.streamOptions?.highWaterMark
          },
          async () => {
            if (this.options.peers && this.options.peers.length > 0) {
              return peerDownloader(
                extractVideoId(q.url),
                this.options.peers[Math.round(Math.random() * (this.options.peers.length - 1))]
              );
            }
            return streamFromYT(q, this.innerTube, {
              overrideDownloadOptions: this.options.overrideDownloadOptions
            });
          }
        );
      };
    }
    _YoutubeiExtractor.instance = this;
    if (this.options.authentication) {
      try {
        await this.signIn(this.options.authentication);
        const info = await this.innerTube.account.getInfo();
        this.context.player.debug(
          info.contents?.contents ? `Signed into YouTube using the name: ${info.contents.contents[0].is(import_youtubei6.YTNodes.AccountItem) ? info.contents.contents[0].as(import_youtubei6.YTNodes.AccountItem).account_name.text ?? "UNKNOWN ACCOUNT" : "UNKNOWN ACCOUNT"}` : `Signed into YouTube using the client name: ${this.innerTube.session.client_name}@${this.innerTube.session.client_version}`
        );
      } catch (error) {
        if (this.options.ignoreSignInErrors)
          process.emitWarning(`Unable to sign into YouTube

${error}`);
        else throw error;
      }
    }
  }
  async signIn(tokens) {
    const tkn = tokenToObject(tokens);
    await this.innerTube.session.signIn(tkn);
  }
  async deactivate() {
    this.protocols = [];
    if (this.options.signOutOnDeactive && this.innerTube.session.logged_in)
      await this.innerTube.session.signOut();
  }
  async validate(query, type) {
    if (typeof query !== "string") return false;
    return [
      import_discord_player.QueryType.YOUTUBE,
      import_discord_player.QueryType.YOUTUBE_PLAYLIST,
      import_discord_player.QueryType.YOUTUBE_SEARCH,
      import_discord_player.QueryType.YOUTUBE_VIDEO,
      import_discord_player.QueryType.AUTO,
      import_discord_player.QueryType.AUTO_SEARCH
    ].some((r) => r === type);
  }
  async bridge(track, ext) {
    if (ext?.identifier === this.identifier) return this.stream(track);
    let protocol;
    if (this.options.overrideBridgeMode) {
      if (typeof this.options.overrideBridgeMode === "string") {
        protocol = this.options.overrideBridgeMode;
      } else if (track.queryType) {
        const opts = this.options.overrideBridgeMode;
        protocol = opts[track.queryType] ?? opts.default;
      }
    }
    if (!protocol) {
      if (this.innerTube.session.logged_in) protocol = "ytmusic";
      else protocol = "yt";
    }
    const query = ext?.createBridgeQuery(track) || `${track.author} - ${track.title}${protocol === "yt" ? " (official audio)" : ""}`;
    switch (protocol) {
      case "ytmusic": {
        try {
          let stream2 = await this.bridgeFromYTMusic(query, track);
          if (!stream2) {
            this.context.player.debug(
              "Unable to bridge from Youtube music. Falling back to default behavior"
            );
            stream2 = await this.bridgeFromYT(query, track);
          }
          return stream2;
        } catch (error) {
          this.context.player.debug(
            "Unable to bridge from youtube music due to an error. Falling back to default behavior\n\n" + error
          );
          return await this.bridgeFromYT(query, track);
        }
      }
      default: {
        return await this.bridgeFromYT(query, track);
      }
    }
  }
  async bridgeFromYTMusic(query, track) {
    const musicSearch = await this.innerTube.music.search(query, {
      type: "song"
    });
    if (!musicSearch.songs) return null;
    if (!musicSearch.songs.contents || musicSearch.songs.contents.length === 0)
      return null;
    if (!musicSearch.songs.contents[0].id) return null;
    const info = await this.innerTube.music.getInfo(
      musicSearch.songs.contents[0].id
    );
    const metadata = new import_discord_player.Track(this.context.player, {
      title: info.basic_info.title ?? "UNKNOWN TITLE",
      duration: import_discord_player.Util.buildTimeCode(
        import_discord_player.Util.parseMS((info.basic_info.duration || 0) * 1e3)
      ),
      author: info.basic_info.author ?? "UNKNOWN AUTHOR",
      views: info.basic_info.view_count,
      thumbnail: info.basic_info.thumbnail?.at(0)?.url,
      url: `https://youtube.com/watch?v=${info.basic_info.id}&dpymeta=ytmusic`,
      source: "youtube",
      queryType: "youtubeVideo",
      live: false
    });
    track.setMetadata(metadata);
    const webStream = await info.download({
      type: "audio",
      quality: "best",
      format: "mp4"
    });
    return createReadableFromWeb(
      webStream,
      this.options.streamOptions?.highWaterMark
    );
  }
  async bridgeFromYT(query, track) {
    const youtubeTrack = await this.handle(query, {
      type: import_discord_player.QueryType.YOUTUBE_SEARCH,
      requestedBy: track.requestedBy
    });
    if (youtubeTrack.tracks.length === 0) return null;
    track.setMetadata({
      bridge: youtubeTrack.tracks[0]
    });
    return this.stream(youtubeTrack.tracks[0]);
  }
  async handle(query, context) {
    if (context.protocol === "ytsearch")
      context.type = import_discord_player.QueryType.YOUTUBE_SEARCH;
    query = query.includes("youtube.com") ? query.replace(/(m(usic)?|gaming)\./, "") : query;
    if (!query.includes("list=RD") && _YoutubeiExtractor.validateURL(query))
      context.type = import_discord_player.QueryType.YOUTUBE_VIDEO;
    switch (context.type) {
      case import_discord_player.QueryType.YOUTUBE_PLAYLIST: {
        let playlist;
        const playlistUrl = new URL(query);
        const plId = playlistUrl.searchParams.get("list");
        const videoId = playlistUrl.searchParams.get("v");
        if (videoId && plId) {
          const endpoint = new import_youtubei6.YTNodes.NavigationEndpoint({
            continuationCommand: {
              videoId,
              playlistId: plId
            }
          });
          const mixVidInfo = await this.innerTube.getInfo(endpoint);
          if (!mixVidInfo?.playlist)
            throw new Error("Mix playlist not found or invalid");
          playlist = {
            info: {
              title: mixVidInfo.playlist.title?.toString() ?? "UNKNOWN TITLE",
              thumbnails: mixVidInfo.playlist.contents?.[0]?.thumbnail ?? [],
              description: "",
              author: {
                name: mixVidInfo.playlist.author?.toString() ?? "UNKNOWN AUTHOR",
                url: ""
              }
            },
            channels: [
              {
                author: {
                  name: mixVidInfo.playlist.author?.toString() ?? "UNKNOWN AUTHOR",
                  url: ""
                }
              }
            ],
            videos: mixVidInfo.playlist.contents.map((item) => ({
              type: "PlaylistVideo",
              id: item.video_id,
              title: { text: item.title?.toString() ?? "UNKNOWN TITLE" },
              duration: { seconds: item.duration?.seconds ?? 0 },
              thumbnails: item.thumbnail?.map((t) => ({ url: t.url })) ?? [],
              author: { name: item.author ?? "UNKNOWN AUTHOR", url: "" },
              is_live: false
            })),
            has_continuation: false,
            async getContinuation() {
              throw new Error("Mixes do not support continuation");
            }
          };
        } else {
          playlist = await this.innerTube.getPlaylist(plId);
        }
        const pl = new import_discord_player.Playlist(this.context.player, {
          title: playlist.info.title ?? "UNKNOWN PLAYLIST",
          thumbnail: playlist.info.thumbnails[0].url,
          description: playlist.info.description ?? playlist.info.title ?? "UNKNOWN DESCRIPTION",
          type: "playlist",
          author: {
            name: playlist?.channels[0]?.author?.name ?? playlist.info.author.name ?? "UNKNOWN AUTHOR",
            url: playlist?.channels[0]?.author?.url ?? playlist.info.author.url ?? "UNKNOWN AUTHOR"
          },
          tracks: [],
          id: plId,
          url: query,
          source: "youtube"
        });
        pl.tracks = [];
        let plTracks = playlist.videos.filter(
          (v) => v.type === "PlaylistVideo"
        ).map((v) => {
          const duration = import_discord_player.Util.buildTimeCode(
            import_discord_player.Util.parseMS(v.duration.seconds * 1e3)
          );
          const raw = {
            duration_ms: v.duration.seconds * 1e3,
            live: v.is_live,
            duration
          };
          return new import_discord_player.Track(this.context.player, {
            title: v.title.text ?? "UNKNOWN TITLE",
            duration,
            thumbnail: v.thumbnails[0]?.url,
            author: v.author.name,
            requestedBy: context.requestedBy,
            url: `https://youtube.com/watch?v=${v.id}`,
            raw,
            playlist: pl,
            source: "youtube",
            queryType: "youtubeVideo",
            async requestMetadata() {
              return this.raw;
            },
            metadata: raw,
            live: v.is_live
          });
        });
        while (playlist.has_continuation) {
          playlist = await playlist.getContinuation();
          plTracks.push(
            ...playlist.videos.filter(
              (v) => v.type === "PlaylistVideo"
            ).map((v) => {
              const duration = import_discord_player.Util.buildTimeCode(
                import_discord_player.Util.parseMS(v.duration.seconds * 1e3)
              );
              const raw = {
                duration_ms: v.duration.seconds * 1e3,
                live: v.is_live,
                duration
              };
              return new import_discord_player.Track(this.context.player, {
                title: v.title.text ?? "UNKNOWN TITLE",
                duration,
                thumbnail: v.thumbnails[0]?.url,
                author: v.author.name,
                requestedBy: context.requestedBy,
                url: `https://youtube.com/watch?v=${v.id}`,
                raw,
                playlist: pl,
                source: "youtube",
                queryType: "youtubeVideo",
                async requestMetadata() {
                  return this.raw;
                },
                metadata: raw,
                live: v.is_live
              });
            })
          );
        }
        pl.tracks = plTracks;
        return {
          playlist: pl,
          tracks: pl.tracks
        };
      }
      case import_discord_player.QueryType.YOUTUBE_VIDEO: {
        let videoId = new URL(query).searchParams.get("v");
        if (!videoId) videoId = query.split("/").at(-1).split("?")[0];
        const vid = await this.innerTube.getBasicInfo(videoId);
        const duration = import_discord_player.Util.buildTimeCode(
          import_discord_player.Util.parseMS((vid.basic_info.duration ?? 0) * 1e3)
        );
        const uploadTime = vid.basic_info.start_timestamp;
        const raw = {
          duration_ms: vid.basic_info.duration * 1e3,
          live: vid.basic_info.is_live,
          duration,
          startTime: uploadTime
        };
        return {
          playlist: null,
          tracks: [
            new import_discord_player.Track(this.context.player, {
              title: vid.basic_info.title ?? "UNKNOWN TITLE",
              thumbnail: vid.basic_info.thumbnail?.at(0)?.url,
              description: vid.basic_info.short_description,
              author: vid.basic_info.channel?.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${vid.basic_info.id}`,
              views: vid.basic_info.view_count,
              duration,
              raw,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw,
              live: vid.basic_info.is_live
            })
          ]
        };
      }
      default: {
        const search = await this.innerTube.search(query);
        const videos = search.videos.filter(
          (v) => v.type === "Video"
        );
        return {
          playlist: null,
          tracks: videos.map((v) => this.buildTrack(v, context))
        };
      }
    }
  }
  buildTrack(vid, context, pl) {
    const duration = import_discord_player.Util.buildTimeCode(
      import_discord_player.Util.parseMS(vid.duration.seconds * 1e3)
    );
    const raw = {
      duration_ms: vid.duration.seconds * 1e3,
      live: vid.is_live
    };
    const track = new import_discord_player.Track(this.context.player, {
      title: vid.title.text ?? "UNKNOWN YOUTUBE VIDEO",
      thumbnail: vid.best_thumbnail?.url ?? vid.thumbnails[0]?.url ?? "",
      description: vid.description ?? vid.title ?? "UNKNOWN DESCRIPTION",
      author: vid.author?.name ?? "UNKNOWN AUTHOR",
      requestedBy: context.requestedBy,
      url: `https://youtube.com/watch?v=${vid.id}`,
      views: parseInt((vid.view_count?.text ?? "0").replaceAll(",", "")),
      duration,
      raw,
      playlist: pl,
      source: "youtube",
      queryType: "youtubeVideo",
      async requestMetadata() {
        return this.raw;
      },
      metadata: raw,
      live: vid.is_live
    });
    track.extractor = this;
    return track;
  }
  stream(info) {
    return this._stream(info, this);
  }
  async getRelatedTracks(track, history) {
    let id = new URL(track.url).searchParams.get("v");
    if (!id) id = track.url.split("/").at(-1)?.split("?").at(0);
    const videoInfo = await this.innerTube.getInfo(id);
    const next = videoInfo.watch_next_feed;
    const recommended = next.filter(
      (v) => !history.tracks.some(
        (x) => x.url === `https://youtube.com/watch?v=${v.id}`
      ) && v.type === "CompactVideo"
    );
    if (!recommended) {
      this.context.player.debug("Unable to fetch recommendations");
      return this.#emptyResponse();
    }
    const trackConstruct = recommended.map((v) => {
      const duration = import_discord_player.Util.buildTimeCode(
        import_discord_player.Util.parseMS(v.duration.seconds * 1e3)
      );
      const raw = {
        live: v.is_live,
        duration_ms: v.duration.seconds * 1e3,
        duration
      };
      return new import_discord_player.Track(this.context.player, {
        title: v.title?.text ?? "UNKNOWN TITLE",
        thumbnail: v.best_thumbnail?.url ?? v.thumbnails[0]?.url,
        author: v.author?.name ?? "UNKNOWN AUTHOR",
        requestedBy: track.requestedBy,
        url: `https://youtube.com/watch?v=${v.id}`,
        views: parseInt((v.view_count?.text ?? "0").replaceAll(",", "")),
        duration,
        raw,
        source: "youtube",
        queryType: "youtubeVideo",
        metadata: raw,
        async requestMetadata() {
          return this.raw;
        },
        live: v.is_live
      });
    });
    return {
      playlist: null,
      tracks: trackConstruct
    };
  }
  #emptyResponse() {
    return {
      playlist: null,
      tracks: []
    };
  }
  static validateURL(link) {
    try {
      _YoutubeiExtractor.parseURL(link);
      return true;
    } catch {
      return false;
    }
  }
  // stolen from  YoutubeExtractor
  static parseURL(link) {
    const parsed = new URL(link.trim());
    let id = parsed.searchParams.get("v");
    if (validPathDomains.test(link.trim()) && !id) {
      const paths = parsed.pathname.split("/");
      id = parsed.host === "youtu.be" ? paths[1] : paths[2];
    } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {
      throw Error("Not a YouTube domain");
    }
    if (!id) {
      throw Error(`No video id found: "${link}"`);
    }
    id = id.substring(0, 11);
    if (!this.validateId(id)) {
      throw TypeError(
        `Video id (${id}) does not match expected format (${idRegex.toString()})`
      );
    }
    return id;
  }
  static validateId(id) {
    return idRegex.test(id.trim());
  }
};

// lib/common/getInstance.ts
function getYoutubeiInstance() {
  return YoutubeiExtractor.instance?.innerTube;
}

// lib/index.ts
var exit = (message, clean) => {
  if (clean) {
    console.log(message);
    process.exit(0);
  }
  throw new Error(message);
};
async function generateOauthTokens() {
  const youtube = await import_youtubei7.default.create({
    retrieve_player: false
  });
  youtube.session.on("auth-pending", (data) => {
    const { verification_url: verify, user_code } = data;
    console.log(
      `Follow this URL: ${verify} and enter this code: ${user_code}
Make sure you are using a throwaway account to login. Using your main account may result in ban or suspension`
    );
  });
  youtube.session.on("auth-error", (err) => {
    exit(err.message, false);
  });
  youtube.session.on("auth", (data) => {
    if (!data.credentials) exit("Something went wrong", false);
    console.log("Your cookies are printed down below");
    console.log(objectToToken(data.credentials));
    exit("Done Getting the credentials", true);
  });
  await youtube.session.signIn();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatMessageType,
  Errors,
  LiveChatEvents,
  YoutubeiExtractor,
  defaultFetch,
  defaultPeerUrlBuilder,
  generateOauthTokens,
  getLiveChat,
  getYoutubeiInstance,
  objectToToken,
  stream,
  tokenToObject,
  validateURL
});
