"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Anvil: () => Anvil,
  CommandAnvil: () => CommandAnvil,
  EventAnvil: () => EventAnvil,
  FILE_REGEXP: () => FILE_REGEXP,
  Hephaestus: () => Hephaestus,
  LoadableBadKey: () => LoadableBadKey,
  LoadableNotFoundError: () => LoadableNotFoundError,
  LoadableTypeError: () => LoadableTypeError,
  PermissionAnvil: () => PermissionAnvil,
  fileLoader: () => file_loader_exports
});
module.exports = __toCommonJS(src_exports);

// src/modules/interaction/command.ts
var import_utils3 = require("@hephaestus/utils");

// src/modules/loadable/constants.ts
var FILE_REGEXP = /^\.?\.?(?!.*\..+\.[cm]?[jt]s$).*\.[cm]?[jt]s$/;

// src/modules/loadable/error.ts
var LoadableTypeError = class extends Error {
  constructor(filePath) {
    super(`Loadable is not correct type. Path: ${filePath}`);
  }
};
var LoadableNotFoundError = class extends Error {
  constructor(filePath) {
    super(`Loadable not found at path "${filePath}"`);
  }
};
var LoadableBadKey = class extends Error {
  constructor(filePath, key) {
    super(`Loadable expected to have key "${key}". Path: ${filePath}`);
  }
};

// src/modules/loadable/file-loader.ts
var file_loader_exports = {};
__export(file_loader_exports, {
  load: () => load,
  loadDirectory: () => loadDirectory,
  reload: () => reload,
  reloadDirectory: () => reloadDirectory,
  unload: () => unload,
  unloadDirectory: () => unloadDirectory
});
var import_fs = require("fs");
var import_path = require("path");
var import_utils = require("@hephaestus/utils");
async function load(path) {
  const loader = async (str) => {
    var _a, _b;
    const fd = await import_fs.promises.stat(str);
    const importName = fd.isDirectory() ? str : (_a = FILE_REGEXP.exec(str)) == null ? void 0 : _a[0];
    if (importName == null) {
      return void 0;
    }
    const data = await Promise.resolve().then(() => __toESM(require(importName)));
    const obj = (_b = data.default) != null ? _b : data;
    obj.filePath = str;
    return obj;
  };
  return Array.isArray(path) ? (0, import_utils.identity)(await Promise.all(path.map(async (p) => await loader(p)))) : await loader(path);
}
function unload(path) {
  const paths = Array.isArray(path) ? path : [path];
  for (const p of paths) {
    delete require.cache[require.resolve(p)];
  }
}
async function reload(path) {
  unload(path);
  return await load(path);
}
async function loadDirectory(path) {
  const files = await import_fs.promises.readdir(path);
  const res = [];
  for (const fd of files) {
    res.push(await load((0, import_path.join)(path, fd)));
  }
  return (0, import_utils.identity)(res);
}
async function unloadDirectory(path) {
  const files = await import_fs.promises.readdir(path);
  unload(files);
}
async function reloadDirectory(path) {
  const files = await import_fs.promises.readdir(path);
  const res = {};
  for (const fd of files) {
    const filePath = (0, import_path.join)(path, fd);
    unload(filePath);
    const loadable = await load(filePath);
    if (loadable) {
      res[filePath] = loadable;
    }
  }
  return res;
}

// src/modules/loadable/map.ts
var import_fs2 = require("fs");
var import_utils2 = require("@hephaestus/utils");
var Anvil = class extends import_utils2.ExtendedMap {
  constructor(key) {
    super();
    this.key = key;
    this.toLoad = [];
    this.reloadPaths = [];
  }
  forge(...loadables) {
    this.toLoad = this.toLoad.concat(loadables.reduce((ax, dx) => ax.concat(Array.isArray(dx) ? dx : [dx]), []));
    return this;
  }
  async hammer(onLoad) {
    var _a, _b;
    const loadables = await this.resolveToLoad();
    for (const loadable of loadables) {
      const key = loadable[this.key];
      if (typeof key !== "string") {
        throw new LoadableBadKey((_a = loadable.filePath) != null ? _a : "", this.key.toString());
      }
      this.set(key, loadable);
      (_b = onLoad != null ? onLoad : this.onLoad) == null ? void 0 : _b(loadable);
    }
    return this;
  }
  async reload(onLoad, onReload) {
    var _a, _b, _c;
    for (const { filePath } of this.values()) {
      if (filePath != null) {
        unload(filePath);
      }
    }
    const oldToLoad = this.toLoad;
    this.toLoad = this.reloadPaths;
    const loadables = await this.resolveToLoad();
    for (const loadable of loadables) {
      const key = loadable[this.key];
      if (typeof key !== "string") {
        throw new LoadableBadKey((_a = loadable.filePath) != null ? _a : "", this.key.toString());
      }
      this.set(key, loadable);
      const oldLoadableObject = this.find((old) => old.filePath === loadable.filePath);
      if (oldLoadableObject) {
        this.delete(oldLoadableObject[this.key]);
        (_b = onReload != null ? onReload : this.onReload) == null ? void 0 : _b(oldLoadableObject, loadable);
      } else {
        (_c = onLoad != null ? onLoad : this.onLoad) == null ? void 0 : _c(loadable);
      }
    }
    this.toLoad = oldToLoad;
    return this;
  }
  async loadFiles(path) {
    this.reloadPaths.push(path);
    const file = await import_fs2.promises.stat(path);
    if (file.isDirectory()) {
      const loadables = await loadDirectory(path);
      const res = [];
      for (const loadable of loadables) {
        if (!this.isValid(loadable)) {
          throw new LoadableTypeError(loadable.filePath);
        }
        res.push(loadable);
      }
      return res;
    } else {
      const loadable = await load(path);
      if (!loadable) {
        throw new LoadableNotFoundError(path);
      }
      if (!this.isValid(loadable)) {
        throw new LoadableTypeError(path);
      }
      return loadable;
    }
  }
  async resolveToLoad() {
    const res = await Promise.all(this.toLoad.map((loadable) => typeof loadable === "string" ? this.loadFiles(loadable) : [loadable]));
    this.toLoad = [];
    return res.reduce((ax, dx) => {
      if (Array.isArray(dx)) {
        return ax.concat(dx);
      } else {
        ax.push(dx);
      }
      return ax;
    }, []);
  }
};

// src/modules/interaction/command.ts
var CommandAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object") {
      return false;
    }
    if (!(0, import_utils3.unknownHasKey)(loadable, "name")) {
      return false;
    }
    if (!(0, import_utils3.unknownHasKey)(loadable, "action")) {
      if (!(0, import_utils3.unknownHasKey)(loadable, "options") || !Array.isArray(loadable.options)) {
        return false;
      }
      return loadable.options.some((option) => {
        if ((0, import_utils3.unknownHasKey)(option, "type")) {
          if (typeof option.type === "number" && option.type <= 2) {
            return true;
          }
        }
        return false;
      });
    }
    return true;
  }
};

// src/modules/interaction/permission.ts
var PermissionAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object" || !("name" in loadable) || !("level" in loadable) || !("action" in loadable)) {
      return false;
    }
    return true;
  }
};

// src/modules/client.ts
var Hephaestus = class {
};

// src/modules/event.ts
var EventAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object" || !("name" in loadable) || !("handler" in loadable)) {
      return false;
    }
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Anvil,
  CommandAnvil,
  EventAnvil,
  FILE_REGEXP,
  Hephaestus,
  LoadableBadKey,
  LoadableNotFoundError,
  LoadableTypeError,
  PermissionAnvil,
  fileLoader
});
