import { ConditionalKeys, Promisable, UnionToIntersection } from 'type-fest';
import { MaybeArray, ExtendedMap } from '@hephaestus/utils';

interface Loadable {
    filePath?: string;
}

declare const FILE_REGEXP: RegExp;

declare class LoadableTypeError extends Error {
    constructor(filePath: string);
}
declare class LoadableNotFoundError extends Error {
    constructor(filePath: string);
}
declare class LoadableBadKey extends Error {
    constructor(filePath: string, key: string);
}

declare type LoadedFile = Required<Loadable>;
declare function load(path: string): Promise<LoadedFile | undefined>;
declare function load(path: string[]): Promise<LoadedFile[]>;
declare function load(path: MaybeArray<string>): Promise<MaybeArray<LoadedFile>>;
declare function unload(path: string | string[]): void;
declare function reload(path: string | string[]): Promise<MaybeArray<LoadedFile>>;
declare function loadDirectory(path: string): Promise<LoadedFile[]>;
declare function unloadDirectory(path: string): Promise<void>;
declare function reloadDirectory(path: string): Promise<Record<string, LoadedFile>>;

type fileLoader_LoadedFile = LoadedFile;
declare const fileLoader_load: typeof load;
declare const fileLoader_unload: typeof unload;
declare const fileLoader_reload: typeof reload;
declare const fileLoader_loadDirectory: typeof loadDirectory;
declare const fileLoader_unloadDirectory: typeof unloadDirectory;
declare const fileLoader_reloadDirectory: typeof reloadDirectory;
declare namespace fileLoader {
  export {
    fileLoader_LoadedFile as LoadedFile,
    fileLoader_load as load,
    fileLoader_unload as unload,
    fileLoader_reload as reload,
    fileLoader_loadDirectory as loadDirectory,
    fileLoader_unloadDirectory as unloadDirectory,
    fileLoader_reloadDirectory as reloadDirectory,
  };
}

declare abstract class Anvil<A, T extends A & Loadable = A & Loadable> extends ExtendedMap<string, T> {
    private readonly key;
    protected toLoad: Array<T | string>;
    protected reloadPaths: string[];
    protected onLoad?(loadable: T): unknown;
    protected onReload?(oldLoadable: T, loadable: T): unknown;
    protected abstract isValid(loadable: unknown): loadable is T;
    constructor(key: ConditionalKeys<T, string>);
    forge(...loadables: Array<MaybeArray<T | string>>): this;
    hammer(onLoad?: (loadable: T) => unknown): Promise<this>;
    reload(onLoad?: (loadable: T) => unknown, onReload?: (loadable: T) => unknown): Promise<this>;
    protected loadFiles(path: string): Promise<MaybeArray<T>>;
    private resolveToLoad;
}

declare abstract class Hephaestus {
    abstract commands: CommandAnvil<Command<any, any, any>>;
    abstract events: EventAnvil<Event>;
    abstract permissions: PermissionAnvil<Permission<any, any, any>>;
    abstract connect(): Promisable<void>;
}

declare type CommandMiddlewareAction<Client, Interaction, OptionsMap, Return = unknown> = (interaction: Interaction, data: OptionsMap, client: Client) => Promisable<Return>;
interface CommandMiddleware<Client, Interaction, OptionsMap, Return = unknown> {
    action: CommandMiddlewareAction<Client, Interaction, OptionsMap, Return>;
}

interface Permission<Client, Interaction, OptionsMap> extends CommandMiddleware<Client, Interaction, OptionsMap, boolean> {
    level: number;
    name: string;
    reason?: string;
}
declare abstract class PermissionAnvil<T extends Permission<any, any, any>> extends Anvil<T> {
    protected isValid(loadable: unknown): loadable is T;
}

declare type AutocompleteAction<Interaction, Option, H extends Hephaestus> = (interaction: Interaction, focusedOption: Option, hephaestus: H) => Promisable<void>;
interface Command<Client, Interaction, OptionsMap> {
    name: string;
    permission?: Permission<Client, Interaction, OptionsMap>;
    middleware?: Array<CommandMiddleware<Client, Interaction, OptionsMap>>;
    guildId?: string;
}
declare type CommandAction<Interaction, H extends Hephaestus> = (interaction: Interaction, hephaestus: H) => Promisable<void>;
declare type CommandActionWithOptions<Interaction, OptionsMap, H extends Hephaestus> = (interaction: Interaction, data: OptionsMap, hephaestus: H) => Promisable<void>;
interface BaseOption {
    name: string;
    required?: boolean;
    type: number;
    choices?: readonly BaseChoice[] | null;
}
interface BaseData {
    value: unknown;
}
interface BaseChoice {
    value: unknown;
}
declare type MaybeUndefined<X, Condition = false> = Condition extends true ? X : X | undefined;
declare type MaybeChoices<B, O extends BaseOption> = O['choices'] extends readonly BaseChoice[] ? B & {
    value: {
        [I in keyof O['choices']]: O['choices'][I];
    }[number]['value'];
} : B;
declare type ConvertOptionsToArgs<T extends readonly BaseOption[], D extends BaseData> = UnionToIntersection<{
    [P in keyof T]: {
        [_ in T[P]['name']]: MaybeUndefined<D & MaybeChoices<{
            type: T[P]['type'];
        }, T[P]>, T[P]['required']>;
    };
}[number]>;
declare abstract class CommandAnvil<T extends Command<any, any, any>> extends Anvil<T> {
    protected isValid(loadable: unknown): loadable is T;
}

interface Event {
    name: string;
    handler: (...args: any) => void;
}
declare abstract class EventAnvil<T extends Event> extends Anvil<T> {
    protected isValid(loadable: unknown): loadable is T;
}

export { Anvil, AutocompleteAction, BaseChoice, BaseData, BaseOption, Command, CommandAction, CommandActionWithOptions, CommandAnvil, CommandMiddleware, ConvertOptionsToArgs, Event, EventAnvil, FILE_REGEXP, Hephaestus, Loadable, LoadableBadKey, LoadableNotFoundError, LoadableTypeError, Permission, PermissionAnvil, fileLoader };
