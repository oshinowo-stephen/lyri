var __defProp = Object.defineProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/modules/interaction/command.ts
import { unknownHasKey } from "@hephaestus/utils";

// src/modules/loadable/constants.ts
var FILE_REGEXP = /^\.?\.?(?!.*\..+\.[cm]?[jt]s$).*\.[cm]?[jt]s$/;

// src/modules/loadable/error.ts
var LoadableTypeError = class extends Error {
  constructor(filePath) {
    super(`Loadable is not correct type. Path: ${filePath}`);
  }
};
var LoadableNotFoundError = class extends Error {
  constructor(filePath) {
    super(`Loadable not found at path "${filePath}"`);
  }
};
var LoadableBadKey = class extends Error {
  constructor(filePath, key) {
    super(`Loadable expected to have key "${key}". Path: ${filePath}`);
  }
};

// src/modules/loadable/file-loader.ts
var file_loader_exports = {};
__export(file_loader_exports, {
  load: () => load,
  loadDirectory: () => loadDirectory,
  reload: () => reload,
  reloadDirectory: () => reloadDirectory,
  unload: () => unload,
  unloadDirectory: () => unloadDirectory
});
import { promises as fs } from "fs";
import { join } from "path";
import {
  identity
} from "@hephaestus/utils";
async function load(path) {
  const loader = async (str) => {
    var _a;
    const fd = await fs.stat(str);
    const importName = fd.isDirectory() ? str : (_a = FILE_REGEXP.exec(str)) == null ? void 0 : _a[0];
    if (importName == null) {
      return void 0;
    }
    const data = await import(importName);
    const obj = data.default ?? data;
    obj.filePath = str;
    return obj;
  };
  return Array.isArray(path) ? identity(await Promise.all(path.map(async (p) => await loader(p)))) : await loader(path);
}
function unload(path) {
  const paths = Array.isArray(path) ? path : [path];
  for (const p of paths) {
    delete __require.cache[__require.resolve(p)];
  }
}
async function reload(path) {
  unload(path);
  return await load(path);
}
async function loadDirectory(path) {
  const files = await fs.readdir(path);
  const res = [];
  for (const fd of files) {
    res.push(await load(join(path, fd)));
  }
  return identity(res);
}
async function unloadDirectory(path) {
  const files = await fs.readdir(path);
  unload(files);
}
async function reloadDirectory(path) {
  const files = await fs.readdir(path);
  const res = {};
  for (const fd of files) {
    const filePath = join(path, fd);
    unload(filePath);
    const loadable = await load(filePath);
    if (loadable) {
      res[filePath] = loadable;
    }
  }
  return res;
}

// src/modules/loadable/map.ts
import { promises as fs2 } from "fs";
import {
  ExtendedMap
} from "@hephaestus/utils";
var Anvil = class extends ExtendedMap {
  constructor(key) {
    super();
    this.key = key;
    this.toLoad = [];
    this.reloadPaths = [];
  }
  forge(...loadables) {
    this.toLoad = this.toLoad.concat(loadables.reduce((ax, dx) => ax.concat(Array.isArray(dx) ? dx : [dx]), []));
    return this;
  }
  async hammer(onLoad) {
    var _a;
    const loadables = await this.resolveToLoad();
    for (const loadable of loadables) {
      const key = loadable[this.key];
      if (typeof key !== "string") {
        throw new LoadableBadKey(loadable.filePath ?? "", this.key.toString());
      }
      this.set(key, loadable);
      (_a = onLoad ?? this.onLoad) == null ? void 0 : _a(loadable);
    }
    return this;
  }
  async reload(onLoad, onReload) {
    var _a, _b;
    for (const { filePath } of this.values()) {
      if (filePath != null) {
        unload(filePath);
      }
    }
    const oldToLoad = this.toLoad;
    this.toLoad = this.reloadPaths;
    const loadables = await this.resolveToLoad();
    for (const loadable of loadables) {
      const key = loadable[this.key];
      if (typeof key !== "string") {
        throw new LoadableBadKey(loadable.filePath ?? "", this.key.toString());
      }
      this.set(key, loadable);
      const oldLoadableObject = this.find((old) => old.filePath === loadable.filePath);
      if (oldLoadableObject) {
        this.delete(oldLoadableObject[this.key]);
        (_a = onReload ?? this.onReload) == null ? void 0 : _a(oldLoadableObject, loadable);
      } else {
        (_b = onLoad ?? this.onLoad) == null ? void 0 : _b(loadable);
      }
    }
    this.toLoad = oldToLoad;
    return this;
  }
  async loadFiles(path) {
    this.reloadPaths.push(path);
    const file = await fs2.stat(path);
    if (file.isDirectory()) {
      const loadables = await loadDirectory(path);
      const res = [];
      for (const loadable of loadables) {
        if (!this.isValid(loadable)) {
          throw new LoadableTypeError(loadable.filePath);
        }
        res.push(loadable);
      }
      return res;
    } else {
      const loadable = await load(path);
      if (!loadable) {
        throw new LoadableNotFoundError(path);
      }
      if (!this.isValid(loadable)) {
        throw new LoadableTypeError(path);
      }
      return loadable;
    }
  }
  async resolveToLoad() {
    const res = await Promise.all(this.toLoad.map((loadable) => typeof loadable === "string" ? this.loadFiles(loadable) : [loadable]));
    this.toLoad = [];
    return res.reduce((ax, dx) => {
      if (Array.isArray(dx)) {
        return ax.concat(dx);
      } else {
        ax.push(dx);
      }
      return ax;
    }, []);
  }
};

// src/modules/interaction/command.ts
var CommandAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object") {
      return false;
    }
    if (!unknownHasKey(loadable, "name")) {
      return false;
    }
    if (!unknownHasKey(loadable, "action")) {
      if (!unknownHasKey(loadable, "options") || !Array.isArray(loadable.options)) {
        return false;
      }
      return loadable.options.some((option) => {
        if (unknownHasKey(option, "type")) {
          if (typeof option.type === "number" && option.type <= 2) {
            return true;
          }
        }
        return false;
      });
    }
    return true;
  }
};

// src/modules/interaction/permission.ts
var PermissionAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object" || !("name" in loadable) || !("level" in loadable) || !("action" in loadable)) {
      return false;
    }
    return true;
  }
};

// src/modules/client.ts
var Hephaestus = class {
};

// src/modules/event.ts
var EventAnvil = class extends Anvil {
  isValid(loadable) {
    if (loadable == null || typeof loadable !== "object" || !("name" in loadable) || !("handler" in loadable)) {
      return false;
    }
    return true;
  }
};
export {
  Anvil,
  CommandAnvil,
  EventAnvil,
  FILE_REGEXP,
  Hephaestus,
  LoadableBadKey,
  LoadableNotFoundError,
  LoadableTypeError,
  PermissionAnvil,
  file_loader_exports as fileLoader
};
