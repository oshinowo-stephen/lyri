// src/modules/interaction/command.ts
import {
  CommandAnvil as CoreCommandAnvil
} from "@hephaestus/core";
function isApplicationCommandOption(option) {
  return option.type >= 3;
}
function getValidSubCommands(options) {
  const res = options.filter((option) => !isApplicationCommandOption(option));
  return res;
}
var CommandMap = class extends CoreCommandAnvil {
};
function createCommand(data) {
  return data;
}

// src/modules/interaction/permission.ts
import {
  PermissionAnvil as CorePermissionAnvil
} from "@hephaestus/core";
var PermissionAnvil = class extends CorePermissionAnvil {
};

// src/modules/client.ts
import {
  AutocompleteInteraction,
  Client,
  CommandInteraction
} from "eris";
import { Hephaestus as CoreHephaestus } from "@hephaestus/core";
import { unknownHasKey } from "@hephaestus/utils";
var Hephaestus = class extends CoreHephaestus {
  constructor(...args) {
    super();
    this.commands = new CommandMap("name");
    this.events = new EventAnvil("name");
    this.permissions = new PermissionAnvil("name");
    const [token, options = { intents: [] }] = args;
    this.client = new Client(token, options);
  }
  async registerCommand(command) {
    if ("guildId" in command && command.guildId != null) {
      await this.client.createGuildCommand(command.guildId, command);
    } else {
      await this.client.createCommand(command);
    }
  }
  registerEvent(event) {
    this.client.on(event.name, event.handler);
  }
  async connect() {
    await Promise.all([
      this.commands.hammer(),
      this.events.hammer(),
      this.permissions.hammer()
    ]);
    this.events.forEach((event) => this.registerEvent(event));
    this.client.on("interactionCreate", async (interaction) => {
      const isCommand = interaction instanceof CommandInteraction;
      const isAutocomplete = interaction instanceof AutocompleteInteraction;
      if (isCommand || isAutocomplete) {
        const command = this.commands.get(interaction.data.name);
        if (command == null) {
          if (isAutocomplete) {
            await interaction.result([]);
            return;
          }
          await interaction.createMessage({
            content: `Command \`${interaction.data.name}\` not found.`,
            flags: 64
          });
          return;
        }
        const middlewares = [...command.middleware ?? []];
        let permission = command.permission ?? null;
        let action;
        let options;
        let interactionOptions;
        if (command.action != null) {
          action = command.action;
          options = command.options;
          interactionOptions = interaction.data.options;
        } else {
          if (interaction.data.options == null || command.options == null) {
            throw new Error(`Command \`${interaction.data.name}\` is not executable.`);
          }
          const option = interaction.data.options[0];
          const subCommand = getValidSubCommands(command.options).find((command2) => command2.name === option.name);
          if (!subCommand) {
            throw new Error(`Command \`${option.name}\` not found.`);
          }
          if (subCommand.middleware != null) {
            middlewares.push(...subCommand.middleware);
          }
          if (subCommand.permission != null && (permission == null || permission.level < subCommand.permission.level)) {
            permission = subCommand.permission;
          }
          if (subCommand.type === 1) {
            action = subCommand.action;
            options = subCommand.options;
            if (option.type === 1) {
              interactionOptions = option.options;
            }
          } else {
            if (!("options" in option) || option.options == null || subCommand.options == null) {
              throw new Error(`Command \`${option.name}\` is not executable.`);
            }
            const lastOption = option.options[0];
            const lastCommand = getValidSubCommands(subCommand.options).find((command2) => command2.name === option.name);
            if (!lastCommand || lastCommand.type !== 1) {
              throw new Error(`Command \`${lastOption.name}\` not found.`);
            }
            if (lastCommand.middleware != null) {
              middlewares.push(...lastCommand.middleware);
            }
            if (lastCommand.permission != null && (permission == null || permission.level < lastCommand.permission.level)) {
              permission = lastCommand.permission;
            }
            action = lastCommand.action;
            options = lastCommand.options;
            if ((lastOption == null ? void 0 : lastOption.type) === 1) {
              interactionOptions = lastOption.options;
            }
          }
        }
        if (isAutocomplete) {
          const focusedOption = interactionOptions == null ? void 0 : interactionOptions.find((option2) => "focused" in option2);
          let option;
          for (const opt of options ?? []) {
            if (opt.name === (focusedOption == null ? void 0 : focusedOption.name)) {
              option = opt;
              break;
            }
          }
          if (!focusedOption || !option || !("autocomplete" in option) || !option.autocomplete) {
            await interaction.result([]);
            return;
          }
          void option.autocompleteAction(interaction, focusedOption, this);
          return;
        }
        const optionsMap = (interactionOptions == null ? void 0 : interactionOptions.reduce((ax, dx) => ({ ...ax, [dx.name]: dx }), {})) ?? {};
        if (permission != null) {
          const level = permission.level;
          let hasPermission = await permission.action(interaction, optionsMap, this.client);
          if (!hasPermission) {
            const overrides = this.permissions.filter((perm) => perm.level > level).sort((a, b) => a.level - b.level);
            for (const override of overrides) {
              hasPermission = await override.action(interaction, optionsMap, this.client);
              if (hasPermission) {
                break;
              }
            }
          }
          if (!hasPermission) {
            const invoker = interaction.acknowledged ? "createFollowup" : "createMessage";
            await interaction[invoker]({
              content: permission.reason ?? "You do not have permission to use this command.",
              flags: 64
            });
            return;
          }
        }
        for (const middleware of middlewares) {
          try {
            await middleware.action(interaction, optionsMap, this.client);
          } catch (error) {
            const invoker = interaction.acknowledged ? "createFollowup" : "createMessage";
            await interaction[invoker]({
              content: unknownHasKey(error, "message") && typeof error.message === "string" ? error.message : "An error occured.",
              flags: 64
            });
          }
        }
        void action(interaction, optionsMap ?? {}, this);
      }
    });
    this.client.on("ready", async () => {
      await Promise.all(this.commands.map(async (command) => await this.registerCommand(command)));
    });
    await this.client.connect();
  }
};

// src/modules/event.ts
import { EventAnvil as CoreEventAnvil } from "@hephaestus/core";
var EventAnvil = class extends CoreEventAnvil {
};
export {
  CommandMap,
  EventAnvil,
  Hephaestus,
  PermissionAnvil,
  createCommand,
  getValidSubCommands,
  isApplicationCommandOption
};
