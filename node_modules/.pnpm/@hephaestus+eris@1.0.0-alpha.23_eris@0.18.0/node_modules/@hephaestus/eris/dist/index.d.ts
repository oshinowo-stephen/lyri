import { Client, AutocompleteInteraction, InteractionDataOptionsWithValue, ApplicationCommandOptionsWithValue, ApplicationCommandOptionChoice, CommandInteraction, UserApplicationCommandStructure, MessageApplicationCommandStructure, ApplicationCommandOptionsSubCommandGroup, ChatInputApplicationCommandStructure, Constants, EventListeners } from 'eris';
import { Hephaestus as Hephaestus$1, AutocompleteAction as AutocompleteAction$1, Command as Command$1, CommandAction as CommandAction$1, CommandActionWithOptions as CommandActionWithOptions$1, ConvertOptionsToArgs, CommandAnvil, CommandMiddleware as CommandMiddleware$1, Permission as Permission$1, PermissionAnvil as PermissionAnvil$1, EventAnvil as EventAnvil$1 } from '@hephaestus/core';

declare class Hephaestus extends Hephaestus$1 {
    commands: CommandMap;
    events: EventAnvil;
    permissions: PermissionAnvil;
    readonly client: Client;
    constructor(...args: ConstructorParameters<typeof Client>);
    private registerCommand;
    private registerEvent;
    connect(): Promise<void>;
}

declare type AllCommandOptionTypes = typeof Constants.ApplicationCommandOptionTypes[keyof typeof Constants.ApplicationCommandOptionTypes];
declare type ApplicationCommandOptionTypes = Exclude<AllCommandOptionTypes, 1 | 2>;
declare type NumberCommandOptionTypes = Extract<ApplicationCommandOptionTypes, 4 | 10>;
declare type AutocompleteCommandOptionTypes = Extract<ApplicationCommandOptionTypes, 3 | 4 | 10>;
declare type AutocompleteAction<T extends AutocompleteCommandOptionTypes> = AutocompleteAction$1<AutocompleteInteraction, {
    type: T;
    focused: true;
} & InteractionDataOptionsWithValue, Hephaestus>;
declare type AutocompleteCommandOption<T extends AutocompleteCommandOptionTypes> = BaseApplicationCommandOption<T> & {
    type: T;
    choices?: never;
    autocomplete: true;
    autocompleteAction: AutocompleteAction<T>;
    min_value?: never;
    max_value?: never;
};
declare type NoAutocompleteCommandOption<T extends ApplicationCommandOptionTypes> = BaseApplicationCommandOption<T> & {
    autocomplete?: false;
    autocompleteAction?: never;
    choices?: readonly ApplicationCommandOptionChoice[];
    min_value?: never;
    max_value?: never;
};
declare type MinMaxCommandOption<T extends NumberCommandOptionTypes> = BaseApplicationCommandOption<T> & {
    autocomplete?: false;
    autocompleteAction?: never;
    choices?: null;
    min_value?: number;
    max_value?: number;
};
declare type BaseApplicationCommandOption<T extends ApplicationCommandOptionTypes> = Omit<ApplicationCommandOptionsWithValue, 'choices' | 'min_value' | 'max_value'> & {
    type: T;
    choices?: readonly ApplicationCommandOptionChoice[] | null;
};
declare type ApplicationCommandOption<T extends ApplicationCommandOptionTypes = ApplicationCommandOptionTypes> = T extends AutocompleteCommandOptionTypes ? T extends NumberCommandOptionTypes ? NoAutocompleteCommandOption<T> | AutocompleteCommandOption<T> | MinMaxCommandOption<T> : NoAutocompleteCommandOption<T> | AutocompleteCommandOption<T> : T extends NumberCommandOptionTypes ? NoAutocompleteCommandOption<T> | MinMaxCommandOption<T> : NoAutocompleteCommandOption<T>;
declare type Command<O> = Command$1<Client, CommandInteraction, O>;
declare type CommandAction = CommandAction$1<CommandInteraction, Hephaestus>;
declare type CommandActionWithOptions<O extends readonly ApplicationCommandOption[]> = CommandActionWithOptions$1<CommandInteraction, ConvertOptionsToArgs<O, InteractionDataOptionsWithValue>, Hephaestus>;
declare type UserCommand = UserApplicationCommandStructure & {
    action: CommandAction;
};
declare type MessageCommand = MessageApplicationCommandStructure & {
    action: CommandAction;
};
declare type SubCommandGroup = Omit<ApplicationCommandOptionsSubCommandGroup, 'options'> & Command<unknown> & {
    options?: readonly ExecutableCommand[];
};
declare type BaseCommand = Omit<ChatInputApplicationCommandStructure, 'options'> & Command<unknown>;
declare type ExecutableCommand<O extends readonly ApplicationCommandOption[] = any> = BaseCommand & {
    options?: O;
    action: CommandActionWithOptions<O>;
};
declare type CommandWithSubCommands<O extends ReadonlyArray<SubCommandGroup | ExecutableCommand> = ReadonlyArray<SubCommandGroup | ExecutableCommand>> = BaseCommand & {
    options: O;
    action?: never;
};
declare type TopLevelCommand<O extends readonly ApplicationCommandOption[] | ReadonlyArray<SubCommandGroup | ExecutableCommand> = readonly ApplicationCommandOption[]> = O extends readonly ApplicationCommandOption[] ? ExecutableCommand<O> : O extends ReadonlyArray<SubCommandGroup | ExecutableCommand> ? CommandWithSubCommands<O> : never;
declare function isApplicationCommandOption(option: SubCommandGroup | ExecutableCommand | ApplicationCommandOption): option is SubCommandGroup | ExecutableCommand;
declare function getValidSubCommands(options: ReadonlyArray<SubCommandGroup | ExecutableCommand | ApplicationCommandOption>): Array<SubCommandGroup | ExecutableCommand>;
declare class CommandMap extends CommandAnvil<TopLevelCommand> {
}
declare function createCommand<O extends readonly ApplicationCommandOption[] | ReadonlyArray<SubCommandGroup | ExecutableCommand> = []>(data: TopLevelCommand<O>): TopLevelCommand<O>;

interface CommandMiddleware<O = unknown, Return = unknown> extends CommandMiddleware$1<Client, CommandInteraction, O, Return> {
}

interface Permission extends Permission$1<Client, CommandInteraction, unknown> {
}
declare class PermissionAnvil extends PermissionAnvil$1<Permission> {
}

declare type Event = {
    [K in keyof EventListeners]: {
        name: K;
        handler: (...args: EventListeners[K]) => void;
    };
}[keyof EventListeners];
declare class EventAnvil extends EventAnvil$1<Event> {
}

export { ApplicationCommandOption, AutocompleteAction, AutocompleteCommandOption, BaseApplicationCommandOption, BaseCommand, Command, CommandAction, CommandActionWithOptions, CommandMap, CommandMiddleware, CommandWithSubCommands, Event, EventAnvil, ExecutableCommand, Hephaestus, MessageCommand, Permission, PermissionAnvil, SubCommandGroup, TopLevelCommand, UserCommand, createCommand, getValidSubCommands, isApplicationCommandOption };
