"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CommandMap: () => CommandMap,
  EventAnvil: () => EventAnvil,
  Hephaestus: () => Hephaestus,
  PermissionAnvil: () => PermissionAnvil,
  createCommand: () => createCommand,
  getValidSubCommands: () => getValidSubCommands,
  isApplicationCommandOption: () => isApplicationCommandOption
});
module.exports = __toCommonJS(src_exports);

// src/modules/interaction/command.ts
var import_core = require("@hephaestus/core");
function isApplicationCommandOption(option) {
  return option.type >= 3;
}
function getValidSubCommands(options) {
  const res = options.filter((option) => !isApplicationCommandOption(option));
  return res;
}
var CommandMap = class extends import_core.CommandAnvil {
};
function createCommand(data) {
  return data;
}

// src/modules/interaction/permission.ts
var import_core2 = require("@hephaestus/core");
var PermissionAnvil = class extends import_core2.PermissionAnvil {
};

// src/modules/client.ts
var import_eris = require("eris");
var import_core3 = require("@hephaestus/core");
var import_utils = require("@hephaestus/utils");
var Hephaestus = class extends import_core3.Hephaestus {
  constructor(...args) {
    super();
    this.commands = new CommandMap("name");
    this.events = new EventAnvil("name");
    this.permissions = new PermissionAnvil("name");
    const [token, options = { intents: [] }] = args;
    this.client = new import_eris.Client(token, options);
  }
  async registerCommand(command) {
    if ("guildId" in command && command.guildId != null) {
      await this.client.createGuildCommand(command.guildId, command);
    } else {
      await this.client.createCommand(command);
    }
  }
  registerEvent(event) {
    this.client.on(event.name, event.handler);
  }
  async connect() {
    await Promise.all([
      this.commands.hammer(),
      this.events.hammer(),
      this.permissions.hammer()
    ]);
    this.events.forEach((event) => this.registerEvent(event));
    this.client.on("interactionCreate", async (interaction) => {
      var _a, _b, _c, _d;
      const isCommand = interaction instanceof import_eris.CommandInteraction;
      const isAutocomplete = interaction instanceof import_eris.AutocompleteInteraction;
      if (isCommand || isAutocomplete) {
        const command = this.commands.get(interaction.data.name);
        if (command == null) {
          if (isAutocomplete) {
            await interaction.result([]);
            return;
          }
          await interaction.createMessage({
            content: `Command \`${interaction.data.name}\` not found.`,
            flags: 64
          });
          return;
        }
        const middlewares = [...(_a = command.middleware) != null ? _a : []];
        let permission = (_b = command.permission) != null ? _b : null;
        let action;
        let options;
        let interactionOptions;
        if (command.action != null) {
          action = command.action;
          options = command.options;
          interactionOptions = interaction.data.options;
        } else {
          if (interaction.data.options == null || command.options == null) {
            throw new Error(`Command \`${interaction.data.name}\` is not executable.`);
          }
          const option = interaction.data.options[0];
          const subCommand = getValidSubCommands(command.options).find((command2) => command2.name === option.name);
          if (!subCommand) {
            throw new Error(`Command \`${option.name}\` not found.`);
          }
          if (subCommand.middleware != null) {
            middlewares.push(...subCommand.middleware);
          }
          if (subCommand.permission != null && (permission == null || permission.level < subCommand.permission.level)) {
            permission = subCommand.permission;
          }
          if (subCommand.type === 1) {
            action = subCommand.action;
            options = subCommand.options;
            if (option.type === 1) {
              interactionOptions = option.options;
            }
          } else {
            if (!("options" in option) || option.options == null || subCommand.options == null) {
              throw new Error(`Command \`${option.name}\` is not executable.`);
            }
            const lastOption = option.options[0];
            const lastCommand = getValidSubCommands(subCommand.options).find((command2) => command2.name === option.name);
            if (!lastCommand || lastCommand.type !== 1) {
              throw new Error(`Command \`${lastOption.name}\` not found.`);
            }
            if (lastCommand.middleware != null) {
              middlewares.push(...lastCommand.middleware);
            }
            if (lastCommand.permission != null && (permission == null || permission.level < lastCommand.permission.level)) {
              permission = lastCommand.permission;
            }
            action = lastCommand.action;
            options = lastCommand.options;
            if ((lastOption == null ? void 0 : lastOption.type) === 1) {
              interactionOptions = lastOption.options;
            }
          }
        }
        if (isAutocomplete) {
          const focusedOption = interactionOptions == null ? void 0 : interactionOptions.find((option2) => "focused" in option2);
          let option;
          for (const opt of options != null ? options : []) {
            if (opt.name === (focusedOption == null ? void 0 : focusedOption.name)) {
              option = opt;
              break;
            }
          }
          if (!focusedOption || !option || !("autocomplete" in option) || !option.autocomplete) {
            await interaction.result([]);
            return;
          }
          void option.autocompleteAction(interaction, focusedOption, this);
          return;
        }
        const optionsMap = (_c = interactionOptions == null ? void 0 : interactionOptions.reduce((ax, dx) => ({ ...ax, [dx.name]: dx }), {})) != null ? _c : {};
        if (permission != null) {
          const level = permission.level;
          let hasPermission = await permission.action(interaction, optionsMap, this.client);
          if (!hasPermission) {
            const overrides = this.permissions.filter((perm) => perm.level > level).sort((a, b) => a.level - b.level);
            for (const override of overrides) {
              hasPermission = await override.action(interaction, optionsMap, this.client);
              if (hasPermission) {
                break;
              }
            }
          }
          if (!hasPermission) {
            const invoker = interaction.acknowledged ? "createFollowup" : "createMessage";
            await interaction[invoker]({
              content: (_d = permission.reason) != null ? _d : "You do not have permission to use this command.",
              flags: 64
            });
            return;
          }
        }
        for (const middleware of middlewares) {
          try {
            await middleware.action(interaction, optionsMap, this.client);
          } catch (error) {
            const invoker = interaction.acknowledged ? "createFollowup" : "createMessage";
            await interaction[invoker]({
              content: (0, import_utils.unknownHasKey)(error, "message") && typeof error.message === "string" ? error.message : "An error occured.",
              flags: 64
            });
          }
        }
        void action(interaction, optionsMap != null ? optionsMap : {}, this);
      }
    });
    this.client.on("ready", async () => {
      await Promise.all(this.commands.map(async (command) => await this.registerCommand(command)));
    });
    await this.client.connect();
  }
};

// src/modules/event.ts
var import_core4 = require("@hephaestus/core");
var EventAnvil = class extends import_core4.EventAnvil {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CommandMap,
  EventAnvil,
  Hephaestus,
  PermissionAnvil,
  createCommand,
  getValidSubCommands,
  isApplicationCommandOption
});
